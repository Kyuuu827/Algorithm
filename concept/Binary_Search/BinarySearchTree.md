## 🌈 이진 탐색 트리(BST: Binary Search Tree)

- 이진 탐색(binary search)과 연결리스트(linked list)를 결합한 자료구조이다. 
- 이진 탐색의 효율적인 탐색 능력의 장점을 유지하면서 빈번한 자료 입력과 삭제가 가능하다. 

  ✔ 이진 탐색 
  - 탐색 시간복잡도는 O(log n), 
  - 자료 입력, 삭제 불가능
  
  ✔ 연결리스트 
  - 탐색 시간복잡도는 O(n)
  - 자료 입력, 삭제의 시간복잡도 O(1)

![](https://images.velog.io/images/lck0827/post/9ca4808f-6ff9-4eac-bc7a-9fcaf44949b1/image.png)

### 이진 탐색 트리의 4가지 조건
1. 모든 노드는 유일한 키를 갖는다.
2. 왼쪽 서브트리의 키들은 루트의 키보다 작다.
3. 오른쪽 서브트리의 키들은 루트의 키보다 크다.
4. 왼쪽과 오른쪽 서브트리도 이진탐색 트리이다. 

![](https://images.velog.io/images/lck0827/post/6d44a293-da06-46d2-8bce-e1ab712a00b7/image.png)

- 이진탐색트리를 순회할 때는 중위순회(inorder) 방식을 쓴다.(왼쪽 서브트리-노드-오른쪽 서브트리 순으로 순회)
- 위의 그림을 중위 순회하면, 4, 10, 12, 15, 17, 19, 20, 26, 28, 30, 33, 35 가 된다. 

---

## 이진 탐색 트리의 연산

### Search
- 이진탐색트리의 탐색 연산에 소요되는 계산복잡성은 트리의 높이(루트노드-잎새노드에 이르는 엣지 수의 최대값)가 ℎ일 때 𝑂(ℎ)가 된다.
- 최악의 경우 잎새노드까지 탐색해야 하기 때문이다. 이 때 ℎ번 비교 연산을 수행한다. 

### Insert
- 삽입 시 가장 중요한 점은 이진 검색 트리의 조건을 유지해야한다는 것!
- 알고리즘은 다음과 같다.

1. root 존재 여부 파악
   - root가 없으면 생성.
   - root가 있으면 root부터 탐색 시작.
2. (root가 있다는 전제) 루트 - 현재 노드를 node라고 한다.
3. 삽입하는 key와 현재 노드 node의 키를 비교한다.
   - key == node : 추가하려는 키가 이미 있으니 삽입을 실패하고 종료
   - key < node :
     - 왼쪽 자식 노드가 없으면, 그 자리에 노드를 만들어서 삽입하고 종료.
     - 왼쪽 자식 노드가 있으면, 현재 노드를 왼쪽 자식 노드로 옮겨서 다시 탐색한다.(재귀)
   - key > node:
     - 오른쪽 자식 노드가 없으면, 그 자리에 노드를 만들어서 삽입하고 종료한다.
     - 오른쪽 자식 노드가 있으면, 현재 노드를 오른쪽 자식 노드로 옮겨서 다시 탐색한다.(재귀)
4. 3번 과정을 반복한다.

### Delete
- 이진 탐색 트리 관련 알고리즘 중 가장 복잡하다. 
- 삽입과 마찬가지로 탐색을 먼저 해야한다. 트리 안에서 삭제하고자하는 키 값의 위치를 알아야 삭제할 수 있기 때문이다. 
- 탐색 후, 삭제시 발생할 수 있는 아래의 상황 3가지 경우를 고려해야 한다. 
1) 삭제하려는 노드가 단말노드일 경우 (자식 노드가 없을 경우)
2) 삭제하려는 노드가 하나의 서브트리만 가지는 경우 (왼쪽 혹은 오른쪽 둘 중 하나만)
3) 삭제하려는 노드가 두 개의 서브트리를 모두 가지고 있는 경우